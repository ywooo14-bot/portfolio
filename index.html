<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>作品集</title>

  <!-- favicon（根据你提供的 favicon_io 文件夹）-->
  <link rel="apple-touch-icon" sizes="180x180" href="favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon_io/favicon-16x16.png">
  <link rel="manifest" href="favicon_io/site.webmanifest">
  <meta name="theme-color" content="#1C1C1C">

  <style>
    /* 基本布局 */
    :root{ --bg:#1C1C1C; --white:#FFFFFF; --skeleton: rgba(255,255,255,0.2); }
    html,body{ height:100%; margin:0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:var(--white); -webkit-font-smoothing:antialiased; }
    .page {
      padding-top:60px; /* 需求：内容区顶部60间距 */
      min-height:100vh;
      box-sizing:border-box;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }

    /* 中央容器：在电脑上占 65% 宽度，最大 1200px；手机上则 100%（由 max-width 规则控制） */
    .container {
      width:65vw;
      max-width:1200px;
      min-width:300px;
      box-sizing:border-box;
    }
    @media (max-width:800px){
      .container{ width:100vw; padding:0 0; }
    }

    /* 图片列：无间距 */
    .gallery{ display:block; margin:0; padding:0; }
    .item{ margin:0; padding:0; position:relative; overflow:hidden; }

    /* skeleton（占位）：高度 1080px，Fill 白色 20% */
    .skeleton{
      width:100%;
      height:1080px; /* 需求：高度1080 */
      background:var(--skeleton);
      display:block;
      box-sizing:border-box;
    }

    /* 图片：宽度 100%，无间隙，Fill */
    .gallery img{
      display:block;
      width:100%;
      height:auto;
      object-fit:cover; /* Fill 效果 */
      vertical-align:middle;
      margin:0;
      padding:0;
      border:0;
      -webkit-user-drag: none; /* 禁止拖动 */
      user-select:none;
    }

    /* 加载过渡淡入 */
    img.fade-in{
      transition:opacity 360ms ease;
      opacity:1;
    }
    img.loading{
      opacity:0;
    }

    /* 遮罩层（网络异常） */
    .overlay {
      position:fixed;
      left:0; top:0; right:0; bottom:0;
      display:flex;
      justify-content:center;
      align-items:center;
      background: rgba(0,0,0,0.6);
      z-index:9999;
      color:var(--white);
      text-align:center;
      padding:20px;
      box-sizing:border-box;
      display:none; /* 默认隐藏，出现时 display:flex */
      flex-direction:column;
    }
    .overlay.show { display:flex; }

    .overlay h2{ margin:0 0 20px 0; font-size:20px; font-weight:600; color:var(--white); }
    .reload-btn{
      width:96px; height:36px;
      font-size:14px; color:var(--white);
      background: var(--skeleton); /* Fill 白色 20% */
      border:0;
      border-radius:4px;
      cursor:pointer;
    }

    /* 为防止右键/拖拽，给图片加一个透明层捕获事件（仍可滚动） */
    .blocker {
      position:absolute; left:0; top:0; right:0; bottom:0;
      z-index:2;
    }

    /* 辅助：页面底部留白，避免最后一张靠边太紧 */
    .spacer{ height:60px; }
  </style>
</head>
<body>
  <div class="page">
    <main class="container" id="mainContainer">
      <section class="gallery" id="gallery" aria-live="polite"></section>
      <div class="spacer"></div>
    </main>
  </div>

  <!-- 网络异常覆盖 -->
  <div class="overlay" id="overlay">
    <h2>网络异常，请重新加载</h2>
    <button class="reload-btn" id="reloadBtn">重新加载</button>
  </div>

  <script>
    /***********************
     * 配置区（小白也能看懂）
     ***********************/
    const MAX_TRY = 50; // 最多尝试检测 work1 .. work50（你可以改这个数字）
    const BASE_PATH = 'images/'; // images 文件夹路径（若你改名需同步修改）
    const PREFIX = 'work';         // 文件名前缀（work）
    const EXT = '.png';           // 扩展名（png）。如果以后是 jpg，可改成 '.jpg' 或做多个扩展判断

    // 连续未找到的阈值：如果连续 X 张图不存在就停止检测（避免一直探测空白编号）
    const STOP_IF_MISSING_IN_ROW = 5;

    const gallery = document.getElementById('gallery');
    const overlay = document.getElementById('overlay');
    const reloadBtn = document.getElementById('reloadBtn');

    // 点击重新加载按钮
    reloadBtn.addEventListener('click', () => location.reload());

    // 在页面上禁止右键菜单（整体）
    document.addEventListener('contextmenu', function(e){ e.preventDefault(); });

    // 改善体验：如果浏览器检测到离线，直接弹提示
    function checkOnline() {
      if (!navigator.onLine) {
        showOverlay();
        return false;
      }
      return true;
    }

    function showOverlay(){
      overlay.classList.add('show');
    }
    function hideOverlay(){
      overlay.classList.remove('show');
    }

    // 主流程：自动探测图片（按 work1,work2,... 顺序）
    async function discoverAndRender() {
      if (!checkOnline()) return;

      let missingInRow = 0;
      let foundAny = false;

      // 我们不会一次性把所有图片都加载（对性能不友好）：先创建占位 skeleton 与 img(data-src)，真正加载由 IntersectionObserver 触发（懒加载）
      for (let i=1;i<=MAX_TRY;i++){
        const filename = PREFIX + i + EXT;
        const url = BASE_PATH + filename;

        // 尝试请求资源头部，确认是否存在 —— 为了兼容更多 host，我们改为使用 Image() 的 onload/onerror 测试（更稳）
        const imgTest = new Image();
        // Use a promise to await test result
        const exists = await new Promise(resolve => {
          imgTest.onload = () => resolve(true);
          imgTest.onerror = () => resolve(false);
          // 这里只开始加载图片的最小体积头部，但浏览器会完整请求图片；这用于“探测是否存在”
          imgTest.src = url + '?_t=' + Date.now(); // 加时间戳避免缓存误判
        });

        if (exists) {
          missingInRow = 0;
          foundAny = true;
          // 创建占位 + img 元素（懒加载）
          const item = document.createElement('div');
          item.className = 'item';
          // skeleton 占位
          const sk = document.createElement('div');
          sk.className = 'skeleton';
          item.appendChild(sk);

          // img 元素：真实 src 放到 data-src，交给 IntersectionObserver 加载
          const img = document.createElement('img');
          img.dataset.src = url;
          img.alt = '作品 ' + i;
          img.className = 'loading';
          img.setAttribute('draggable','false');
          // 当图片真正加载完成：移除 skeleton，淡入
          img.onload = () => {
            img.classList.remove('loading');
            img.classList.add('fade-in');
            if (img.previousElementSibling && img.previousElementSibling.classList.contains('skeleton')) {
              img.previousElementSibling.remove();
            }
          };
          // 如果加载失败：保留 skeleton（用户可点击刷新）
          img.onerror = () => {
            img.remove(); // 如果某些时候加载失败，移除该 img（占位已经存在）
            // 作为次优策略：如果很多图都加载失败，提示网络异常
          };

          // 为阻止右键/拖拽，我们在 img 上放一个透明捕获层
          const blocker = document.createElement('div');
          blocker.className = 'blocker';
          // 阻止所有鼠标事件（但是允许滚动穿过）
          blocker.addEventListener('contextmenu', e => e.preventDefault());
          blocker.addEventListener('mousedown', e => e.preventDefault());
          blocker.addEventListener('dragstart', e => e.preventDefault());

          item.appendChild(img);
          item.appendChild(blocker);
          gallery.appendChild(item);
        } else {
          missingInRow++;
          if (missingInRow >= STOP_IF_MISSING_IN_ROW) {
            break; // 连续 N 张都没找到，停止后续探测
          }
        }
      } // end for

      // 如果没找到任何图片，显示网络异常/或空白提示
      if (!foundAny) {
        showOverlay();
        return;
      }

      // 设置懒加载：IntersectionObserver
      const imgs = document.querySelectorAll('img[data-src]');
      const observerOptions = {
        root: null,
        rootMargin: '300px', // 预加载：在进入视口前 300px 开始加载，提高体验
        threshold: 0
      };
      const io = new IntersectionObserver((entries, ob) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const el = entry.target;
            el.src = el.dataset.src;
            ob.unobserve(el);
          }
        });
      }, observerOptions);

      imgs.forEach(img => io.observe(img));

      // 监测加载错误率：如果大量图片出错，则提示网络异常。策略：5 秒后统计加载成功的 img 数量
      setTimeout(() => {
        const total = document.querySelectorAll('.item').length;
        const loaded = document.querySelectorAll('img.fade-in').length;
        // 如果加载成功比例小于 30% ，则提示网络问题
        if (total>0 && loaded/total < 0.3) {
          showOverlay();
        } else {
          hideOverlay();
        }
      }, 5000);
    }

    // 初始化
    (function init(){
      discoverAndRender().catch(err=>{
        console.error(err);
        showOverlay();
      });
    })();

    // 额外提示：当离线状态改变时自动刷新或显示 overlay
    window.addEventListener('offline', showOverlay);
    window.addEventListener('online', () => {
      hideOverlay();
    });

  </script>
</body>
</html>
